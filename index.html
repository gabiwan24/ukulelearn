<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Loop Master Mobile</title>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- Babel für JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- FontAwesome Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        /* Verhindert Pull-to-Refresh und Bouncing auf Mobile */
        body {
            overscroll-behavior-y: none;
            touch-action: manipulation;
        }

        /* WICHTIG: Verhindert Scrollen beim Bedienen der Timeline */
        .no-scroll-touch {
            touch-action: none;
        }
        
        .file-input-hidden {
            opacity: 0;
            position: absolute;
            z-index: -1;
        }
        /* Einheitlicher Button */
        .btn {
            @apply h-9 min-w-[2.25rem] px-3 rounded-md bg-white/10 text-white/90 border border-white/20 text-sm font-medium active:bg-white/20 transition;
        }
        .btn-icon {
            @apply h-9 w-9 rounded-md flex items-center justify-center;
        }
    </style>
</head>
<body class="bg-gray-950 text-gray-100 font-sans antialiased h-screen overflow-hidden flex flex-col">
    <div id="root" class="h-full flex flex-col"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        const formatTime = (seconds) => {
            if (isNaN(seconds)) return "00:00.0";
            const min = Math.floor(seconds / 60);
            const sec = Math.floor(seconds % 60);
            const ms = Math.floor((seconds % 1) * 10);
            return `${min}:${sec < 10 ? '0' : ''}${sec}.${ms}`;
        };

        function App() {
            // File & Video State
            const [localFileUrl, setLocalFileUrl] = useState(null);
            const [localFileName, setLocalFileName] = useState('');
            const [videoTitle, setVideoTitle] = useState('');
            const videoRef = useRef(null);
            const timelineRef = useRef(null);

            // Playback State
            const [isPlaying, setIsPlaying] = useState(false);
            const [currentTime, setCurrentTime] = useState(0);
            const [duration, setDuration] = useState(100);
            
            // Loop State
            const [loopStart, setLoopStart] = useState(0);
            const [loopEnd, setLoopEnd] = useState(100);
            const [isLooping, setIsLooping] = useState(true);

            // UI State: ein Overlay, zwei Ansichten
            const [showOverlay, setShowOverlay] = useState(false);
            const [overlayView, setOverlayView] = useState('setup'); // 'setup' | 'library'
            const [showSavePopup, setShowSavePopup] = useState(false);
            const [saveSuccessMessage, setSaveSuccessMessage] = useState(false);
            const [showNameVideoPopup, setShowNameVideoPopup] = useState(false);
            const [showControls, setShowControls] = useState(true);
            const [isMuted, setIsMuted] = useState(false);
            const [playbackRate, setPlaybackRate] = useState(1);
            const [isDragging, setIsDragging] = useState(false);
            const stateRef = useRef({ loopStart, loopEnd, duration });

            // Storage
            const [savedLoops, setSavedLoops] = useState([]);
            const [loopName, setLoopName] = useState('');

            // --- Init & Event Listeners ---
            useEffect(() => {
                const stored = localStorage.getItem('localMusicLoops');
                if (stored) setSavedLoops(JSON.parse(stored));
            }, []);

            useEffect(() => {
                stateRef.current = { loopStart, loopEnd, duration };
            }, [loopStart, loopEnd, duration]);

            useEffect(() => {
                const v = videoRef.current;
                if (!v) return;
                v.muted = isMuted;
            }, [isMuted, localFileUrl]);

            useEffect(() => {
                const v = videoRef.current;
                if (!v) return;
                v.playbackRate = playbackRate;
            }, [playbackRate, localFileUrl]);

            useEffect(() => {
                const video = videoRef.current;
                if (!video) return;

                const handleLoadedMetadata = () => {
                    const dur = video.duration;
                    setDuration(dur);
                    setLoopStart(0);
                    setLoopEnd(dur);
                };
                
                const handlePlay = () => setIsPlaying(true);
                const handlePause = () => setIsPlaying(false);
                
                video.addEventListener('loadedmetadata', handleLoadedMetadata);
                video.addEventListener('play', handlePlay);
                video.addEventListener('pause', handlePause);

                return () => {
                    video.removeEventListener('loadedmetadata', handleLoadedMetadata);
                    video.removeEventListener('play', handlePlay);
                    video.removeEventListener('pause', handlePause);
                };
            }, [localFileUrl]);

            // --- Loop Engine ---
            useEffect(() => {
                let animationFrameId;
                const checkLoop = () => {
                    if (videoRef.current) {
                        const curr = videoRef.current.currentTime;
                        // Nur UI updaten wenn wir nicht gerade ziehen (Performance & Jitter)
                        if (!isDragging) {
                            setCurrentTime(curr);
                        }

                        if (isLooping && isPlaying && !isDragging) {
                            if (curr >= loopEnd) {
                                videoRef.current.currentTime = loopStart;
                                if (videoRef.current.paused) videoRef.current.play();
                            }
                        }
                    }
                    animationFrameId = requestAnimationFrame(checkLoop);
                };
                animationFrameId = requestAnimationFrame(checkLoop);
                return () => cancelAnimationFrame(animationFrameId);
            }, [isLooping, loopEnd, loopStart, isPlaying, isDragging]);

            // --- Touch & Mouse Logic (Only Playhead Seek) ---
            
            const handleSeek = (clientX) => {
                if (!timelineRef.current) return;
                const rect = timelineRef.current.getBoundingClientRect();
                const x = clientX - rect.left;
                const percentage = Math.max(0, Math.min(1, x / rect.width));
                const newTime = percentage * stateRef.current.duration;

                // Immer nur Playhead verschieben
                if (videoRef.current) videoRef.current.currentTime = newTime;
                setCurrentTime(newTime);
            };

            // Global Move/Up Listeners für Dragging
            useEffect(() => {
                if (!isDragging) return;

                const handleMove = (e) => {
                    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                    handleSeek(clientX);
                };
                
                const handleUp = () => setIsDragging(false);

                window.addEventListener('mousemove', handleMove);
                window.addEventListener('mouseup', handleUp);
                window.addEventListener('touchmove', handleMove, { passive: false });
                window.addEventListener('touchend', handleUp);

                return () => {
                    window.removeEventListener('mousemove', handleMove);
                    window.removeEventListener('mouseup', handleUp);
                    window.removeEventListener('touchmove', handleMove);
                    window.removeEventListener('touchend', handleUp);
                };
            }, [isDragging]);


            // --- Actions ---

            const handleFileUpload = (e) => {
                const file = e.target.files[0];
                if (file) {
                    if (localFileUrl) URL.revokeObjectURL(localFileUrl);
                    const url = URL.createObjectURL(file);
                    setLocalFileUrl(url);
                    setLocalFileName(file.name);
                    setVideoTitle(file.name);
                    setShowNameVideoPopup(true);
                    setIsPlaying(false);
                }
            };
            const confirmVideoName = () => {
                if (videoTitle.trim()) setShowNameVideoPopup(false);
            };

            const togglePlay = () => {
                const video = videoRef.current;
                if (!video) return;
                video.paused ? video.play() : video.pause();
            };

            // Spacebar (Desktop): Play/Pause – nicht in Eingabefeldern
            useEffect(() => {
                const handleKeyDown = (e) => {
                    if (e.code !== 'Space' && e.key !== ' ') return;
                    const target = e.target;
                    if (target && (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable)) return;
                    e.preventDefault();
                    togglePlay();
                };
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, []);

            const nudge = (type, amount) => {
                if (type === 'start') {
                    setLoopStart(prev => Math.max(0, Math.min(prev + amount, loopEnd - 0.05)));
                } else {
                    setLoopEnd(prev => Math.min(duration, Math.max(prev + amount, loopStart + 0.05)));
                }
            };

            const setStartToCurrent = () => setLoopStart(Math.max(0, currentTime));
            const setEndToCurrent = () => setLoopEnd(Math.min(duration, currentTime));

            // --- Library & Storage ---

            const saveLoop = () => {
                if (!loopName.trim()) return;
                const newLoop = {
                    id: Date.now(),
                    name: loopName,
                    fileName: localFileName,
                    videoTitle: videoTitle || localFileName,
                    start: loopStart,
                    end: loopEnd
                };
                const updated = [...savedLoops, newLoop];
                setSavedLoops(updated);
                localStorage.setItem('localMusicLoops', JSON.stringify(updated));
                setLoopName('');
                setSaveSuccessMessage(true);
                setTimeout(() => { setSaveSuccessMessage(false); setShowSavePopup(false); }, 1200);
            };

            const loadSavedLoop = (loop) => {
                if (loop.fileName !== localFileName) {
                    alert(`Video "${loop.videoTitle || loop.fileName}" laden für diesen Loop.`);
                    return;
                }
                setLoopStart(loop.start);
                setLoopEnd(loop.end);
                if (videoRef.current) videoRef.current.currentTime = loop.start;
                setShowOverlay(false);
            };

            const deleteLoop = (id) => {
                const updated = savedLoops.filter(l => l.id !== id);
                setSavedLoops(updated);
                localStorage.setItem('localMusicLoops', JSON.stringify(updated));
            };

            // Export / Import
            const exportData = () => {
                const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(savedLoops));
                const downloadAnchorNode = document.createElement('a');
                downloadAnchorNode.setAttribute("href", dataStr);
                downloadAnchorNode.setAttribute("download", "loop_master_backup.json");
                document.body.appendChild(downloadAnchorNode);
                downloadAnchorNode.click();
                downloadAnchorNode.remove();
            };

            const importData = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const imported = JSON.parse(event.target.result);
                        const merged = [...imported, ...savedLoops];
                        const unique = merged.filter((v,i,a)=>a.findIndex(v2=>(v2.id===v.id))===i);
                        setSavedLoops(unique);
                        localStorage.setItem('localMusicLoops', JSON.stringify(unique));
                        alert(`${imported.length} Loops importiert.`);
                    } catch (err) {
                        alert("Fehler beim Importieren.");
                    }
                };
                reader.readAsText(file);
            };

            // Styles
            const trackStyle = {
                left: `${(loopStart / duration) * 100}%`,
                width: `${Math.max(0, (loopEnd - loopStart) / duration) * 100}%`
            };
            const playheadStyle = { left: `${(currentTime / duration) * 100}%` };

            return (
                <div className="fixed inset-0 bg-black">
                    
                    {/* Top: Video laden + Titel + Menü ein/aus (oben rechts) */}
                    {showControls && (
                        <div className="absolute top-0 left-0 right-0 z-20 pl-3 pr-3 pt-2 pb-2 bg-gradient-to-b from-black/70 to-transparent flex items-center gap-2 min-h-[44px]">
                            <label className="flex items-center gap-2 cursor-pointer text-white/90 text-sm min-h-[36px] shrink-0">
                                <i className="fas fa-folder-open text-white/80"></i>
                                <input type="file" accept="video/*,audio/*" onChange={handleFileUpload} className="file-input-hidden" />
                            </label>
                            {localFileUrl ? (
                                <span className="flex-1 min-w-0 truncate text-sm text-white/90">{videoTitle}</span>
                            ) : (
                                <span className="text-sm text-white/70">Video laden</span>
                            )}
                            <button onClick={() => setIsMuted(!isMuted)} className="w-10 h-10 rounded-lg bg-white/10 border border-white/20 flex items-center justify-center text-white/90 shrink-0 ml-auto" title={isMuted ? "Ton an" : "Stumm"}><i className={`fas ${isMuted ? 'fa-volume-mute' : 'fa-volume-up'} text-sm`}></i></button>
                            <button onClick={() => setShowControls(false)} className="w-10 h-10 rounded-lg bg-white/10 border border-white/20 flex items-center justify-center text-white/90 shrink-0" title="Menü ausblenden"><i className="fas fa-chevron-down text-sm"></i></button>
                        </div>
                    )}
                    {!showControls && (
                        <div className="absolute top-2 right-3 z-20 flex items-center gap-2">
                            <button onClick={() => setIsMuted(!isMuted)} className="w-10 h-10 rounded-lg bg-white/10 border border-white/20 flex items-center justify-center text-white/90 shrink-0" title={isMuted ? "Ton an" : "Stumm"}><i className={`fas ${isMuted ? 'fa-volume-mute' : 'fa-volume-up'} text-sm`}></i></button>
                            <button onClick={() => setShowControls(true)} className="w-10 h-10 rounded-lg bg-white/10 border border-white/20 flex items-center justify-center text-white/90 shrink-0" title="Menü einblenden"><i className="fas fa-chevron-up text-sm"></i></button>
                        </div>
                    )}

                    {/* VIDEO: Vollbild, nicht skaliert, an Oberkante */}
                    <div 
                        className="absolute inset-0 flex justify-center"
                        onClick={() => { if(!isDragging) togglePlay(); }}
                    >
                        <video 
                            ref={videoRef}
                            src={localFileUrl}
                            className="w-full h-full object-contain object-top"
                            playsInline
                            webkit-playsinline="true"
                        />
                        {!localFileUrl && (
                            <div className="absolute inset-0 flex items-center justify-center">
                                <span className="text-white/40 text-sm">Noch kein Video geladen</span>
                            </div>
                        )}
                    </div>

                    {/* Control-Bar ein-/ausblendbar */}
                    {showControls ? (
                        <div className="absolute bottom-0 left-0 right-0 z-20 px-3 py-2 bg-gradient-to-t from-black/90 to-transparent safe-pb flex flex-col gap-1.5">
                            <div className="flex items-center justify-between">
                                <div className="flex items-center gap-2 flex-1 min-w-0">
                                    <span className="text-xs font-mono text-white/80 w-10 shrink-0">{formatTime(currentTime)}</span>
                                    <div 
                                        className="relative flex-1 h-8 flex items-center no-scroll-touch cursor-pointer touch-none min-w-0"
                                        ref={timelineRef}
                                        onMouseDown={(e) => { setIsDragging(true); handleSeek(e.clientX); }}
                                        onTouchStart={(e) => { setIsDragging(true); handleSeek(e.touches[0].clientX); }}
                                    >
                                        <div className="absolute left-0 right-0 h-1.5 bg-white/25 rounded-full overflow-hidden pointer-events-none">
                                            <div className="absolute top-0 h-full bg-white/50 rounded-full" style={trackStyle}></div>
                                        </div>
                                        <div className="absolute h-3.5 w-3.5 -ml-1.5 top-1/2 -translate-y-1/2 z-10 bg-white rounded-full pointer-events-none shadow" style={playheadStyle}></div>
                                    </div>
                                    <span className="text-xs font-mono text-white/80 w-10 shrink-0 text-right">{formatTime(duration)}</span>
                                </div>
                            </div>
                            <div className="flex items-center justify-between gap-1 w-full flex-wrap">
                                <div className="flex items-center gap-1">
                                    <button onClick={togglePlay} disabled={!localFileUrl} className="w-10 h-10 rounded-lg bg-white/15 flex items-center justify-center text-white disabled:opacity-40 active:bg-white/25" title="Play/Pause"><i className={`fas ${isPlaying ? 'fa-pause' : 'fa-play'} text-sm`}></i></button>
                                    <button onClick={() => { if (videoRef.current) { videoRef.current.pause(); videoRef.current.currentTime = 0; setCurrentTime(0); } }} disabled={!localFileUrl} className="w-10 h-10 rounded-lg bg-white/15 flex items-center justify-center text-white disabled:opacity-40 active:bg-white/25" title="Stopp"><i className="fas fa-stop text-sm"></i></button>
                                </div>
                                <div className="flex items-center gap-0.5">
                                    {[1, 0.75, 0.5, 0.25].map((rate) => (
                                        <button key={rate} onClick={() => setPlaybackRate(rate)} disabled={!localFileUrl} className={`h-8 min-w-[2.25rem] px-2 rounded-lg text-xs font-mono disabled:opacity-40 ${playbackRate === rate ? 'bg-white/25 text-white' : 'bg-white/10 text-white/70'}`}>{rate}x</button>
                                    ))}
                                </div>
                                <div className="flex items-center gap-1">
                                    <button onClick={setStartToCurrent} disabled={!localFileUrl} className="h-9 w-14 min-w-[3.5rem] rounded-lg bg-emerald-600/90 text-white font-semibold text-xs active:bg-emerald-500 disabled:opacity-40">IN</button>
                                    <button onClick={setEndToCurrent} disabled={!localFileUrl} className="h-9 w-14 min-w-[3.5rem] rounded-lg bg-red-600/90 text-white font-semibold text-xs active:bg-red-500 disabled:opacity-40">OUT</button>
                                </div>
                                <div className="flex items-center gap-1">
                                    <button onClick={() => setIsLooping(!isLooping)} className={`w-10 h-10 rounded-lg flex items-center justify-center ${isLooping ? 'bg-white/25 text-white' : 'bg-white/10 text-white/50'}`} title={isLooping ? "Loop aus" : "Loop an"}><i className="fas fa-sync-alt text-sm"></i></button>
                                    <button onClick={() => setShowSavePopup(true)} disabled={!localFileUrl} className="w-10 h-10 rounded-lg bg-white/15 flex items-center justify-center text-white disabled:opacity-40 active:bg-white/25" title="Sequenz speichern"><i className="fas fa-save text-sm"></i></button>
                                    <button onClick={() => setShowOverlay(true)} className="w-10 h-10 rounded-lg bg-white/15 flex items-center justify-center text-white active:bg-white/25" title="Gespeicherte Sequenzen"><i className="fas fa-list text-sm"></i></button>
                                </div>
                            </div>
                        </div>
                    ) : null}

                    {/* Overlay: Gespeicherte Sequenzen (schwarzes Player-Design) */}
                    {showOverlay && (
                        <div 
                            className="fixed inset-0 z-40 bg-black/90 flex flex-col justify-end"
                            onClick={() => { setShowOverlay(false); setShowSavePopup(false); }}
                        >
                            <div 
                                className="bg-black border-t border-white/10 rounded-t-2xl safe-pb max-h-[85vh] flex flex-col"
                                onClick={(e) => e.stopPropagation()}
                            >
                                <div className="flex items-center justify-between px-4 py-3 border-b border-white/10 shrink-0">
                                    <span className="text-sm text-white/90">Gespeicherte Sequenzen</span>
                                    <button onClick={() => setShowOverlay(false)} className="w-10 h-10 rounded-lg bg-white/10 flex items-center justify-center text-white/90"><i className="fas fa-times"></i></button>
                                </div>
                                <div className="flex-1 overflow-y-auto px-4 pb-2 space-y-2 min-h-0 pt-2">
                                    {savedLoops.length === 0 ? (
                                        <p className="py-6 text-center text-white/50 text-sm">Noch keine Loops gespeichert</p>
                                    ) : (
                                        [...savedLoops].sort((a, b) => a.id - b.id).map(loop => (
                                            <div 
                                                key={loop.id} 
                                                className={`min-h-[56px] p-3 rounded-lg border flex justify-between items-center cursor-pointer active:scale-[0.99] ${loop.fileName === localFileName ? 'bg-white/10 border-white/20' : 'bg-white/5 border-white/10 opacity-70'}`}
                                                onClick={() => loadSavedLoop(loop)}
                                            >
                                                <div className="overflow-hidden min-w-0 flex-1">
                                                    <div className="text-sm font-medium text-white/90 truncate">{loop.name}</div>
                                                    <div className="text-xs text-white/50 truncate">{loop.videoTitle || loop.fileName}</div>
                                                </div>
                                                <button onClick={(e) => { e.stopPropagation(); deleteLoop(loop.id); }} className="w-10 h-10 rounded-lg flex items-center justify-center text-white/50 active:text-red-400 shrink-0" aria-label="Löschen"><i className="fas fa-trash"></i></button>
                                            </div>
                                        ))
                                    )}
                                </div>
                                <div className="p-4 border-t border-white/10 flex gap-2 shrink-0">
                                    <button onClick={exportData} className="flex-1 min-h-[44px] rounded-lg bg-white/10 border border-white/20 text-white/90 text-sm flex items-center justify-center gap-2">Export</button>
                                    <label className="flex-1 min-h-[44px] rounded-lg bg-white/10 border border-white/20 text-white/90 text-sm flex items-center justify-center gap-2 cursor-pointer">Import<input type="file" accept=".json" onChange={importData} className="hidden" /></label>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* Popup: Sequenz benennen & speichern (schwarz) */}
                    {showSavePopup && (
                        <div className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black/90" onClick={() => !saveSuccessMessage && setShowSavePopup(false)}>
                            <div className="bg-black rounded-2xl border border-white/20 w-full max-w-sm p-4 shadow-xl" onClick={(e) => e.stopPropagation()}>
                                {saveSuccessMessage ? (
                                    <p className="text-center text-white py-4 text-base">Gespeichert!</p>
                                ) : (
                                    <>
                                        <p className="text-sm text-white/80 mb-3">Name der Sequenz</p>
                                        <input
                                            type="text"
                                            placeholder="z. B. Strophe 1, Bridge"
                                            className="w-full bg-white/10 border border-white/20 rounded-lg px-3 py-2.5 text-sm text-white placeholder-white/40 focus:outline-none focus:border-white/40 mb-4 min-h-[44px]"
                                            value={loopName}
                                            onChange={(e) => setLoopName(e.target.value)}
                                            autoFocus
                                        />
                                        <div className="flex gap-2">
                                            <button onClick={() => setShowSavePopup(false)} className="flex-1 min-h-[44px] rounded-lg bg-white/10 border border-white/20 text-white/90 text-sm">Abbrechen</button>
                                            <button onClick={saveLoop} disabled={!loopName.trim()} className="flex-1 min-h-[44px] rounded-lg bg-white/20 border border-white/20 text-white text-sm gap-2 disabled:opacity-50 flex items-center justify-center"><i className="fas fa-save"></i> Speichern</button>
                                        </div>
                                    </>
                                )}
                            </div>
                        </div>
                    )}

                    {/* Popup: Video einen Namen geben (nach Laden) */}
                    {showNameVideoPopup && (
                        <div className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black/90" onClick={() => {}}>
                            <div className="bg-black rounded-2xl border border-white/20 w-full max-w-sm p-4 shadow-xl" onClick={(e) => e.stopPropagation()}>
                                <p className="text-sm text-white/80 mb-3">Name für dieses Video</p>
                                <input
                                    type="text"
                                    placeholder="z. B. Liedtitel"
                                    className="w-full bg-white/10 border border-white/20 rounded-lg px-3 py-2.5 text-sm text-white placeholder-white/40 focus:outline-none focus:border-white/40 mb-4 min-h-[44px]"
                                    value={videoTitle}
                                    onChange={(e) => setVideoTitle(e.target.value)}
                                    autoFocus
                                />
                                <button onClick={confirmVideoName} disabled={!videoTitle.trim()} className="w-full min-h-[44px] rounded-lg bg-white/20 border border-white/20 text-white text-sm disabled:opacity-50">Übernehmen</button>
                            </div>
                        </div>
                    )}

                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
